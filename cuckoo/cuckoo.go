// Copyright 2018 The Gringo Developers. All rights reserved.
// Use of this source code is governed by a GNU GENERAL PUBLIC LICENSE v3
// license that can be found in the LICENSE file.

package cuckoo

import (
	"encoding/binary"
	"github.com/sirupsen/logrus"
	"golang.org/x/crypto/blake2b"
)

// Edge represents an edge in the cuckoo graph from vertex U to vertex V.
type Edge struct {
	U uint64
	V uint64

	usedU bool
	usedV bool
}

// findCycleLength attempts to walk the given edges and returns the length of
// the cycle.
func findCycleLength(edges []*Edge) int {
	i := 0     // first node
	cycle := 0 // the current length of the cycle

loop:
	for {
		// If the current cycle length is even we need to look for an edge from
		// U -> V.
		vertexInUPartition := cycle&1 == 0

		if vertexInUPartition {
			// Find an unused edge that connects to the current vertex.
			for j := range edges {
				if j != i && !edges[j].usedU && edges[i].U == edges[j].U {
					edges[i].usedU = true
					edges[j].usedU = true

					i = j
					cycle++

					continue loop
				}
			}
		} else {
			// Find an unused edge that connects to the current vertex.
			for j := range edges {
				if j != i && !edges[j].usedV && edges[i].V == edges[j].V {
					edges[i].usedV = true
					edges[j].usedV = true

					i = j
					cycle++

					continue loop
				}
			}
		}

		// If we didn't find a match for this vertex then we're done.
		break
	}

	return cycle
}

// findCycleLengthCuckatoo attempts to walk the given edges and returns the
// length of the cycle. This version differs in that it doesn't compare the last
// bit of each vertex.
func findCycleLengthCuckatoo(edges []*Edge) int {
	i := 0     // first node
	cycle := 0 // the current length of the cycle

loop:
	for {
		// If the current cycle length is even we need to look for an edge from
		// U -> V.
		vertexInUPartition := cycle&1 == 0

		if vertexInUPartition {
			// Find an unused edge that connects to the current vertex.
			for j := range edges {
				// We ignore the last bit during this comparison.
				if j != i && !edges[j].usedU && (edges[i].U>>1) == (edges[j].U>>1) {
					edges[i].usedU = true
					edges[j].usedU = true

					i = j
					cycle++

					continue loop
				}
			}
		} else {
			// Find an unused edge that connects to the current vertex.
			for j := range edges {
				// We ignore the last bit during this comparison.
				if j != i && !edges[j].usedV && (edges[i].V>>1) == (edges[j].V>>1) {
					edges[i].usedV = true
					edges[j].usedV = true

					i = j
					cycle++

					continue loop
				}
			}
		}

		// If we didn't find a match for this vertex then we're done.
		break
	}

	return cycle
}

// NewCuckatoo returns a new instance of a Cuckoo cycle verifier. key is the data used
// to derived the siphash keys from and sizeShift is the number of vertices in
// the cuckoo graph as an exponent of 2.
func NewCuckatoo(key []byte, edgeBits uint8) *Cuckoo {
	size := uint64(1) << edgeBits
	mask := size - 1

	bsum := blake2b.Sum256(key)
	key = bsum[:]

	var v [4]uint64
	v[0] = binary.LittleEndian.Uint64(key[:8])
	v[1] = binary.LittleEndian.Uint64(key[8:16])
	v[2] = binary.LittleEndian.Uint64(key[16:24])
	v[3] = binary.LittleEndian.Uint64(key[24:32])

	return &Cuckoo{
		mask: mask,
		size: size,
		v:    v,
	}
}

// Cuckoo cycle context
type Cuckoo struct {
	mask uint64

	// size is the number of vertices in the cuckoo graph.
	size uint64

	// v is the key for siphash
	v [4]uint64
}

func (c *Cuckoo) newNode(nonce uint64, i uint64) uint64 {
	return siphash24(c.v, 2*nonce+i) & c.mask
}

func (c *Cuckoo) NewEdge(nonce uint32) *Edge {
	return &Edge{
		U: c.newNode(uint64(nonce), 0),
		V: c.newNode(uint64(nonce), 1),
	}
}

// Verify constructs a cuckoo subgraph from the edges generated by nonces and
// checks whether they form a cycle of the correct length.
func (c *Cuckoo) Verify(nonces []uint32) bool {
	proofSize := len(nonces)

	// zero proof is always invalid
	if proofSize == 0 {
		return false
	}

	// Create graph edges from the nonces.
	edges := make([]*Edge, proofSize)
	for i := 0; i < proofSize; i++ {
		// Ensure nonces are in ascending order and that they are all of the
		// correct easiness.
		if uint64(nonces[i]) > c.mask || (i != 0 && nonces[i] <= nonces[i-1]) {
			logrus.Infof("Nonce %d is invalid", i)
			return false
		}

		edges[i] = c.NewEdge(nonces[i])
	}

	return findCycleLengthCuckatoo(edges) == proofSize
}

// Cuckaroo is the asic-resistant version of the cuckoo-cycle mining algorithm.
type Cuckaroo struct {
	// v is the key for siphash
	v [4]uint64
}

// NewCuckaroo returns a new instance of a Cuckaroo cycle verifier. key is the
// data used to derived the siphash keys from and sizeShift is the number of
// vertices in the cuckoo graph as an exponent of 2.
func NewCuckaroo(key []byte) *Cuckaroo {
	bsum := blake2b.Sum256(key)
	key = bsum[:]

	var v [4]uint64
	v[0] = binary.LittleEndian.Uint64(key[:8])
	v[1] = binary.LittleEndian.Uint64(key[8:16])
	v[2] = binary.LittleEndian.Uint64(key[16:24])
	v[3] = binary.LittleEndian.Uint64(key[24:32])

	return &Cuckaroo{
		v: v,
	}
}

// NewFromKeys returns a new instance of a Cuckaroo verifier with the given key.
func NewFromKeys(keys [4]uint64) *Cuckaroo {
	return &Cuckaroo{
		v: keys,
	}
}

// Verify constructs a cuckaroo subgraph from the edges generated by nonces and
// checks whether they form a cycle of the correct length.
func (c *Cuckaroo) Verify(nonces []uint32, edgeBits uint8) bool {
	proofSize := len(nonces)

	// zero proof is always invalid
	if proofSize == 0 {
		return false
	}

	numEdges := uint64(1<<edgeBits) - 1

	// Create graph edges from the nonces.
	edges := make([]*Edge, proofSize)
	for i := 0; i < proofSize; i++ {
		// Ensure nonces are in ascending order and that they are in the correct
		// range.
		if uint64(nonces[i]) > numEdges || (i != 0 && nonces[i] <= nonces[i-1]) {
			logrus.Infof("Nonce %d is invalid", i)
			return false
		}

		edges[i] = c.NewEdge(nonces[i], numEdges)
	}

	return findCycleLength(edges) == proofSize
}

func (c *Cuckaroo) NewEdge(nonce uint32, mask uint64) *Edge {
	e := siphashBlock(c.v, uint64(nonce))
	return &Edge{
		U: e & mask,
		V: (e >> 32) & mask,
	}
}
